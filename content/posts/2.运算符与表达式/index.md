---
title: 2.运算符与表达式
date: 2025-11-26T19:44:40Z
lastmod: 2025-11-26T19:45:04Z
---

# 2.运算符与表达式

> vscode 常用快捷键

```
    ctrl + c    复制
    ctrl + v    粘贴
    tab 缩进
    shift + tab 往前
    ctrl + /    快捷注释
    ctrl + a    全选
    ctrl + x    剪切
    shift +　ctrl 配合方向键 进行文本选择
    ctrl + z    撤销
    ctrl + y    取消撤销
    win + v     剪切板
    .....

```

# 概述

```c
    在C语言中，运算符(operator) 与 表达式(expression) 是两个相关但是不同的概念
    运算符是用于执行特定操作的符号或者关键字，他们用于组成表达式，执行各种计算和操作

    C语言提供了多种运算符:
    算数运算符(如加减乘除)、关系运算符(如等于、大于、小于)、逻辑运算符(与、或、非)等。

    比如:
        int c = a + b; //这是一个表达式，使用了加法运算符+ 

```

# 1.运算符

```c
用来表示某种运算的符号
    x目运算符 : 表示这个运算符要带几个操作数

    单目运算符: 该运算符只需要一个操作数: ++ -- &
    双目运算符: 该运算符需要两个操作数: + - * /
    三目运算符: 该运算符需要三个操作数: ? : 

    结合性: 决定先算哪个操作数的问题
        从左至右结合还是从右至左结合
    
    如:
        a + b
        b + a
        在C语言中含义是不一样的, + 结合性: 从左至右结合
    例子:
        int i = 5, j = 6;
        int a; 

        a = (i++) + (i+j);  // 5 + 12 == 17
        或者
        a = (i+j) + (i++);  // 11 + 5 == 16
    尝试分析上述 a 的值会不会不同
    写程序分别执行上述两个式子， 检验结果


    运算符的优先级:
        在含有多个运算符的表达式中，决定先算哪个运算符后算运算符
    如：
        a + b * c
    
    单目运算符 > 算术运算符 > 关系运算符 > 逻辑运算符 > 赋值运算符 > 逗号运算符 

    
```

# 2.表达式

```
表达式就是表达某个意思的式子，C语言中，一般来说，表达式指用运算符连接操作数的式子

    a + b
    123
    hello world
    ....

*合法的表达式一定会有一个值，因为任何表达式都需要表达某意思

```

# 3.运算符分类

## 3.1 算数运算符

```c
    ++ --       单目运算符
    + - * /  %  双目运算符


*注意:
    1. + - * / 只需要操作数是一个数(整数/小数/整型变量/浮点变量)
        例如:
            3+6
            3.0 + 4
            int a,b;
            a+b;
            double fa , fc;
            fa + fc;
    2. ++ -- % 要求操作数必须为整数
        3.5 % 3 //error
---------------------
    5 / 4 --> 1
    5.0 / 4 --> 1.25

    若a,b为 int 型，如果希望的到实数的结果:
    1.0*a/b
*注意:
    整数/整数   得到的结果还是整数，如果想要得到实数，可以在最前面 * 1.0
    1.0*5/2 --->
    隐式转换: 高精度与低精度数据计算式，其结果自动向高精度转换

--------------------
% : 取余运算符，在C语言总，要求两个操作数都为整数，并且 不能对 0 取余
    5%4 -- > 1
    6%7 -- > 6
    -5%2 -- > -1
    5%-2 -- > 1

-------------------
    ++ 自增(+1) 运算符，单目运算符，要求操作数必须为一个左值(lvalue)
    -- 自减(-1) 运算符，单目运算符，要求操作数必须为一个左值(lvalue)

    5++ ; //错误
    (a+b)++ ; //错误
    //int* p ; 
    //p++ ; //正确

        表达式的值      做完表达式后i的值
i++         i           i = i+1
++i         i+1         i = i+1
i--         i           i = i-1
--i         i-1         i = i-1


```

## 3.2 关系运算符

```
双目运算符，结合性从左至右
    <  <= >=  >
    ==  !=

关系表达式: 用关系运算符连接起来的式子， 如: a <  b , 3+4 < 6
关系表达式的值
    关系成立   1 (非0 表示真)
    关系不成立 0 (表示假)

    例如:
        5 > 2   1
        3 <= 4  1

        3+6 < 6*9
            ==> 3+6 < 54
            ==> 9 < 54  (1)

        9>8>7   这是一个合法的关系表达式
        
                拿"9>8" 的值 和 7 进行比较
                1 > 7 ==> 0
        注意: 这个表达式和数学上的含义是不一样的
        1.在C语言中  9>8>7 ==> 1>7
        2.在数学上  9>8>7  ==> 9>8 并且 8>7
    
```

## 3.3 逻辑运算符

```
    !       逻辑非 单目运算符          "取反"
    &&      逻辑与 双目运算符          "并且"
    ||      逻辑或 双目运算符          "或者"

    逻辑表达式: 用逻辑运算符连接起来的式子，逻辑表达式

    逻辑表达式的值:
        逻辑真      1(非0)
        逻辑假      0

    例如:
        int a = 43, b = 5;
            a && b ==> 1
            a || b ==> 1
            !a || b ==> 1
            !a && b ==> 0 

        6>4 && 8<2-9
             1 && 0 ==> 0
```

## 练习

```c
    分析如下程序的输出结果:
    int a,b,c,d,m,n;
    a = 1; b = 2; c = 3; d = 4;
    m = 1; n = 1;
    (m = a>b) && (n = c>d);
    printf("%d,%d,%d,%d,%d,%d\n",a,b,c,d,m,n); //1，2，3，4，0，1 
                    
```

> 上述程序 n = c>d; 没有执行，原因: 逻辑短路
> 求值规则是从左到右进行，并且遇到第一个为假的表达式时停止计算，并返回假
> 右边的表达式将不会被计算

```c
C语言中的运算符是"惰性运算"
    (1) a && b && c
        只有a为真时，才需要判断b的值
        只有a和b都为真时，才需要判断c的值
    (2) a || b || c
        只要a为真，则整体为真，不需要判断b和c的值
        a为假时，才会判断b的值
        a和b都为假时，才会判断c的值

    如果已经知道了表达式的值，那么后面的运算符或者表达式就不需要执行
    ----> 惰性运算


```

## 练习

```c
    1.用逻辑表达式判断 y (年份) 是否为闰年
        "四年一闰，百年不闰，四百年又闰"

    只要求写出逻辑表达式即可，不用编写程序

        a.能被4整除，但是不能被100整除
        b.能够被4整除，同时能够被400整除
        上述条件满足其一，则为闰年

        a                           b
    (y%4 == 0 && y%100 != 0) || (y%400 == 0)



    2.用逻辑表达式判断 y (年份) 是否为非闰年
        !((a)||(b))

```

## 3.4 位运算符

```c
位运算符是按bit位展开来进行的，位运算符要求操作数必须为整数(兼容的整数)
因为进行位运算时，需要把操作数按照bit位展位，"按每个bit位进行操作"

    &   按位与
    |   按位或
    ~   按位取反
    ^   按位异或
    <<  按位左移
    >>  按位右移

    *除了~是单目运算外，其他的位运算符都是双目运算符，结合性是从左至右的。
    位运算操作数只能是整型(整型,字符型) 
--------
    ~ (按位取反)
    1--> 0
    0--> 1


    练习:
        int a = ~(-3);
        //先按照bit展开, 求存储形式
        (-3)
        0000 0000 0000 0000 0000 0000 0000 0011  //绝对值原码
        1111 1111 1111 1111 1111 1111 1111 1100  //取反
        1111 1111 1111 1111 1111 1111 1111 1101  //+1  
        ~(-3)
        0000 0000 0000 0000 0000 0000 0000 0010  //变量a中存储的内容

        printf("%d \n",a);  //2
        printf("%u \n",a);  //2

        int a = !(-3);
        //非0值 取非 变 0
        printf("%d \n",a);  //0
        printf("%u \n",a);  //0

*注意:
    ~ 按位取反 和 ！逻辑非 是不一样的

--------
    &(按位与)
    a&b

    a   b   a & b
    1   1     1
    1   0     0
    0   1     0
    0   0     0

    & 如果两个bit位都为1，则结果为1，否则为0.

    例:
    3 & 5 = ? //1
        0000 0000 0000 0000 0000 0000 0000 0011 (3)
      & 0000 0000 0000 0000 0000 0000 0000 0101 (5)
        0000 0000 0000 0000 0000 0000 0000 0001 (1)
    3 & 7 = ? //3
        0000 0000 0000 0000 0000 0000 0000 0011 (3)
      & 0000 0000 0000 0000 0000 0000 0000 0111 (7)
        0000 0000 0000 0000 0000 0000 0000 0011 (3)

    3 && 8 = 1
        //此处为逻辑与  两个非0值相与 结果1
*注意:
    & 按位与 和 && 逻辑与 是不一样的
 

*结论:
    任意bit位与0 按位与'&' ，结果为0 
    任意bit位与1 按位与'&' ，结果为其本身

--------
    | (按位或)
    a   b   a|b
    1   1   1
    1   0   1   
    0   1   1
    0   0   0
    按位或，只要一个bit位操作数为1，其结果就为1 

    3|5 = ? //7
        0000 0000 0000 0000 0000 0000 0000 0011 (3)
      | 0000 0000 0000 0000 0000 0000 0000 0101 (5)
        0000 0000 0000 0000 0000 0000 0000 0111 (7)

    3||5 = ? //1

*注意:
    | 按位或 和 && 逻辑或 是不一样的   

    
    练习:
        有一个整型变量a，要使其第4bit(bit从0开始，0 1 2 3 4)置1，其他bit不变。应该如何操作?
        a = (a|16);


*结论:
    任意bit位与0 按位或'|' ，结果为其本身
    任意bit位与1 按位或'|' ，结果为1


--------
    ^ (按位异或)
    "异或" : 求异  不相同则为 1 ，相同则为 0
    a   b   a^b
    1   1   0
    1   0   1
    0   1   1
    0   0   0

    例:
        3 ^ 5  = ? //6
        0000 0000 0000 0000 0000 0000 0000 0011 (3)
      ^ 0000 0000 0000 0000 0000 0000 0000 0101 (5) 
        0000 0000 0000 0000 0000 0000 0000 0110 (6)

*结论:
    任意bit位与0 按位异或'^'，结果为其本身
    任意bit位与1 按位异或'^'，结果取反

--------
    <<  按位左移
    a << n  把a按照bit位整体左移n位
    高位左移后，舍弃，低位 补0
*如果左移舍弃的高位全部为0，那么左移n位后，表示在原值乘2的n次方
    例如：将 3 左移2 位,变为12, 表示3乘2的2次方
        0000 0000 0000 0000 0000 0000 0000 0011 (3)
        0000 0000 0000 0000 0000 0000 0000 1100 (12)

    >>  按位右移
    a >> n  把a按照bit位整体右移n位
    注意:
        对于无符号数，右移后的高位全部补0
        对于有符号数，右移后的高位全部补符号位

```

## 练习

```c
    求如下程序的输出结果
    (1) 
        int a = -1;
        a = a >> 31;
        1111 1111 1111 1111 1111 1111 1111 1111  (-1)
        >>31  有符号，右移补符号位1
        1111 1111 1111 1111 1111 1111 1111 1111  (右移后的结果)

        printf("%d \n",a ); // -1
        printf("%u \n",a ); // 2^32 -1

        unsigned int a = -1;
        a = a >> 31;
        1111 1111 1111 1111 1111 1111 1111 1111  (-1)
        >>31  无符号，右移补0
        0000 0000 0000 0000 0000 0000 0000 0001  (右移后的结果)

        printf("%d \n",a ); // 1
        printf("%u \n",a ); // 1


    (2) 
        char a = -1;
        int b = a >> 31 ;
        1111 1111 (-1)
        >> 31  
        a提升为32为后 右移31位
        1111 1111 1111 1111 1111 1111 1111 1111 
        然后将其赋值给b 

        printf("%d \n",b);  //-1
        printf("%u \n",b);  //2^32 -1

        unsigned char a = -1;
        int b = a >> 31;
        a:
            1111 1111 
        a>>31:
        a提升为32后右移31位
        0000 0000 0000 0000 0000 0000 1111 1111 >> 31
        无符号 补 0 
        printf("%d \n",b);  //0
        printf("%u \n",b);  //0



```

## 3.5赋值运算符 =

```c
双目运算符，结合性从右至左
    a = b;
    把表达式b的值赋值给a(a必须是一个可写的地址，具备左值)
    一般来说 a 为一个可变的数据对象，"变量"
    赋值运算符的左边(左操作数)必须为一个"可写的地址" ,左值

    例如:
        23  = 24 ;//错误

        22 + 3 = 12; //错误

        int i = 6;
        i++ = 6; //错误 赋值左边必须是可写的地址，左值
        i  = 6; //正确

    赋值表达式: 由赋值运算符连接操作数的式子
    赋值表达式的值: 就是赋值后左边的操作数的值
    i = 13; 
    
    a = i = 13; //正确的 ,a的值为 13 等效于a = (i = 13)


    复合的赋值运算符: 赋值运算符可以和算数运算符、位运算符组成复合的赋值运算符

    +=  -= *= /=  %=
    示例:
    a += b; //等效于==> a = a+b;

```

## 3.6条件运算符

```c
三目运算符， 结合性 从右至左

    格式:
        expression ? a:b
        如果expression 表达式的值为真，则整个条件表达式的值为 a
        如果expression 表达式的值为假，则整个条件表达式的值为 b

    如: 
        if(a>b)
        {
            a = 1;
        }
        else
        {
            a = 2;
        }


        a = (a>b)? 1:2;
        或者
        (a>b)? ( a = 1):( a = 2);

    三目运算符要求 表达式a 和表达式b的类型相同或者兼容
    错误示例: (x>y)? 'A': 0

```

## 3.7逗号运算符

```c
双目运算符 优先级是最低的，结合性从左至右
    表达式1,表达式2
    逗号表达式求值顺序: 先求表达式1的值，然后再求表达式2 的值
    整个逗号表达式的值，就是表达式2 (最后)的值

    例如:
        int a = 5, b = 6;
        a = (a=6,a+b); 
        printf("a : %d \n",a);
        先执行 a=6，再执行a+b,最后将a+b的结果赋值给a

总结:
    可以在一个表达式中按顺序执行多个子表达式，并以最后一个子表达式的值作为整个表达式的结果
```

```
    8.指针运算符
        *
        &
    9.求字节运算符
        sizeof
    10.分量运算符
        求结构体的成员变量
        .
        ->
    11.下表运算符
        []
        int a[10];
        a[0];


    12.强制转换类型运算符
        (类型)值

    13.其他
        比如函数调用运算符

```

## 作业

```c
基础题:
    1. int a = 1，b =1 ,c= 1;
    int d = a || (b=b-1)&&(c=c-1);

    求 a b c 的值?

    a || (b=b-1)&&(c=c-1)
    ---> a || ((b=b-1)&&(c=c-1))
    相当于 a || X 
    a为1，后续X部分不参与运算，"惰性运算"
    a,b,c,d都为1
    
    2. 不使用除法，判断一个数是奇数还是偶数
    使用除法:  (d % 2 == 0) //能够被 2 整除即为偶数
    
    偶数二进制位的最低为必定为0，而奇数必定为1
    假设要判断n是否为偶数
    n & 1 == 0; //最低位为0 ，偶数
    n & 1 == 1; //最低位为1，奇数


    3. 将32位变量a的第k位清0，其他位不变
        31 30 29 .....  3 2 1 0
    a:
        1111 1111 1111 1111 1111 1111 1111 1111 
        1<<k,1停留在k位，同时其他位为0
        取反,k位为0 ，其他位为1，
        此时，二者相与，第k位清0，其他位与1，所以不变

        a &= ~(1<<k)

        将第k位置1,其他位不变:
        a |= (1<<k);

        将第k位翻转(0变1， 1变0)
        a ^= (1<<k)


扩展:
    1. 不使用新的变量，交换a b 的值

    提示: 可以使用加减法或者位运算实现
    加减法:
    a = a + b;
    b = a - b;
    a = a - b;


可选:
    2. 不使用'+' 实现求两数之和  

    提示: 位运算

    比如: 1+2
    0001 (1) 
  ^ 0010 (2)    
    -----
    0011 (3) 
    //异或 可以实现类似加法的效果 (不带进位)
    但是有进位时:
    先异或
    1001 (9)
   ^0011 (3)
   -------
    1010 (10)
    刚好缺失了进位，所以需要补上进位
    1001
   &0011
    ----
    0001 进位后(2)加进原本异或的结果中(10)，确保数值正确
    (0001 <<1)  +  1010 (10) == 12
    


```
